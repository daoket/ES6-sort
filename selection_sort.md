# 选择排序 Selection Sort
### 原理：每一次内循环遍历寻找`最小数的下标min`，并在这次内循环结束后交换 min 和 j 的位置。
### 时间复杂度
- 最优时间复杂度：O(n2)
- 最坏时间复杂度：O(n2)
- 稳定性：不稳定

```
function selection_sort(arr) {
  let len = arr.length
  for (let j = 0; j < len-1; j++) {
    let min = j
    for (let i = j + 1; i < len; i++) {
      if (arr[min] > arr[i]) {
        min = i
      }
    }
    if (min !== j) {
      [arr[min], arr[j]] = [arr[j], arr[min]]
      // console.log(arr)
    }
  }
}
let arr = [7, 4, 3, 67, 34, 1, 8]
selection_sort(arr) // [ 1, 3, 4, 7, 8, 34, 67 ]
```
解析：将每一次外循环的值，和内循环中的值依次比较，如果在内循环中找小于自己的值，就将min这个下标指向内循环中的`较小值的下标`，之后在循环中比较较小值和下一个值，最后找到内循环中最小值的下标，内循环结束后将内循环最小值和外循环值交换。
循环参数： 外循环： 0-->n-2, 内循环：j+1-->n-i  

这里解释下为什么这种排序是不稳定的，假设一个数组有重复数

```
let arr = [1, '4', 3, 67, 34, 4, 7, 8] // `4`和4完全相同，加引号是为了说明方便

取最小值：[1, 3, '4', 4, 7, 8, 34,  67]
取最大值：[ 67, 34, 8, 7, '4', 4, 3, 1] 翻转后-->[1, 3, 4, '4', 7, 8, 34,  67]
```
聪明你发现了吗，两种排序后重复值4位置竟然发生了改变，所以这种算法是不稳定的